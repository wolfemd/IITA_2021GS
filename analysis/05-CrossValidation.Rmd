---
title: "Parent-wise cross-validation to check the accuracy of predicting cross (co)-variances"
author: "Marnin Wolfe"
date: "2021-May-14"
output: 
  workflowr::wflow_html:
    toc: true
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = F, 
                      eval = FALSE, # <- NOTE THAT EVAL SET TO FALSE!
                      tidy='styler', tidy.opts=list(strict=FALSE,width.cutoff=100), highlight=TRUE)
```

# Previous step

4.  [Preprocess data files](04-PreprocessDataFiles.html): Prepare haplotype and dosage matrices, pedigree and BLUPs, genetic map *and* recombination frequency matrix, for use in predictions.

# Automating cross-validation

In the manuscript, the cross-validation is documented many pages and scripts, [documented here](https://wolfemd.github.io/PredictOutbredCrossVar/).

For ongoing GS, I have a function `runCrossVal()` that manages all inputs and outputs easy to work with pre-computed accuracies.

Goal here is to make a function: `runParentWiseCrossVal()`, or at least make progress towards developing one.

*However*, for computational reasons, I imagine it might still be best to separate the task into a few functions.

My goal is to simplify and integrate into the pipeline used for NextGen Cassava. In the paper, used multi-trait Bayesian ridge-regression (MtBRR) to obtain marker effects, and also stored posterior matrices on disk to later compute posterior mean variances. This was computationally expensive and different from my standard univariate REML approach. I think MtBRR and PMV are probably the least biased way to go... but...

For the sake of testing a simple integration into the in-use pipeline, I want to try univariate REML to get the marker effects, which I'll subsequently use for the cross-validation.

Revised the functions in **`package:predCrossVar`** to increase the computational efficiency. Not yet included into the actual R package but instead sourced from `code/predCrossVar.R`. Additional speed increases were achieved by extra testing to optimize balance of `OMP_NUM_THREADS` setting (multi-core BLAS) and parallel processing of the  crosses-being-predicted. Improvements will benefit users predicting with REML / Bayesian-VPM, but probably worse for Bayesian-PMV.

# Set-up server computing env.

Use a a singularity image from the rocker project, as recommended by Qi Sun to get an OpenBLAS-linked R environment that packages can easily be installed on.

```{bash, eval=F}
# copy the project data
cd /home/jj332_cas/marnin/;
cp -R implementGMSinCassava /home/$USER;
# the project directory can be in my networked folder for 2 reasons:
# 1) singularity will automatically recognize and be able to access it
# 2) My analyses not read/write intensive; don't break server rules/etiquette 
# set up a working directory on the remote machine
mkdir /workdir/$USER
cd /workdir/$USER/; 

# pull a singularity image and save in the file rocker.sif
# next time you use the rocker.sif file to start the container
singularity pull rocker.sif docker://rocker/tidyverse:latest;
```


```{bash, eval=F}
# a) start a screen shell
# b) start the singularity Linux shell inside that
# c) start R
## Old options for controlling multi-thread BLAS
### export OMP_NUM_THREADS
#export OMP_NUM_THREADS=5; R;
### or as a one liner
#OMP_NUM_THREADS=5 R
### NEW: within R session! See below...
# cd /workdir/$USER/; 


screen; 
singularity shell /workdir/$USER/rocker.sif; 
cd /home/mw489/implementGMSinCassava/;
R

```

# Run parent-wise cross-validation

Fully-tested `runParentWiseCrossVal()` and component functions are in the `code/parentWiseCrossVal.R` script. Below, source it and use it for a full cross-validation run. 
```{r install packages if needed}
# install.packages(c("RhpcBLASctl","here","rsample","sommer","psych"))
#install.packages(c("psych"))

# RhpcBLASctl::get_num_procs() # 112
# RhpcBLASctl::blas_get_num_procs()
```

```{r primary inputs}
require(tidyverse); require(magrittr); 
RhpcBLASctl::blas_set_num_threads(5)

# SOURCE CORE FUNCTIONS
# source(here::here("code","parentWiseCrossVal.R"))
# source(here::here("code","predCrossVar.R"))

# PEDIGREE
ped<-read.table(here::here("output","verified_ped.txt"),
                header = T, stringsAsFactors = F) %>% 
  rename(GID=FullSampleName,
         damID=DamID,
         sireID=SireID) %>% 
  dplyr::select(GID,sireID,damID)
# Keep only families with _at least_ 2 offspring
ped %<>%
  semi_join(ped %>% count(sireID,damID) %>% filter(n>1) %>% ungroup())

# BLUPs
blups<-readRDS(file=here::here("data","blups_forCrossVal.rds")) %>% 
  dplyr::select(-varcomp)

# GENOMIC RELATIONSHIP MATRICES (GRMS)
grms<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
           D=readRDS(file=here::here("output",
                                     "kinship_domGenotypic_IITA_2021July5.rds")))
## using A+domGenotypic (instead of domClassic used previously)
## will achieve appropriate dom effects for predicting family mean TGV
## but resulting add effects WILL NOT represent allele sub. effects and thus
## predictions won't equal GEBV, allele sub. effects will be post-computed
## as alpha = a + d(q-p)

# DOSAGE MATRIX
dosages<-readRDS(file=here::here("data",
                                 "dosages_IITA_filtered_2021May13.rds"))

# RECOMBINATION FREQUENCY MATRIX
recombFreqMat<-readRDS(file=here::here("data",
                                       "recombFreqMat_1minus2c_2021May13.rds"))
# HAPLOTYPE MATRIX
## keep only haplos for parents-in-the-pedigree
## those which will be used in prediction, saves memory
haploMat<-readRDS(file=here::here("data","haps_IITA_filtered_2021May13.rds"))
parents<-union(ped$sireID,ped$damID) 
parenthaps<-sort(c(paste0(parents,"_HapA"),
                   paste0(parents,"_HapB")))
haploMat<-haploMat[parenthaps,colnames(recombFreqMat)]

# SELECTION INDEX WEIGHTS
## from IYR+IK
## note that not ALL predicted traits are on index
SIwts<-c(logFYLD=20,
         HI=10,
         DM=15,
         MCMDS=-10,
         logRTNO=12,
         logDYLD=20,
         logTOPYLD=15,
         PLTHT=10) 
```

# Integrate modelType="DirDom" 

## Initial steps
```{r test inputs runParentWiseCrossVal}
nrepeats=1
nfolds=2
seed=53
modelType="DirDom"
ncores=10
outName="output/test_dirdom"
ped=ped
gid="GID"
selInd=TRUE
SIwts<-SIwts[1:2]
blups %<>% 
  filter(Trait %in% names(SIwts))
```
```{r unaltered makeParentFolds func}
# source makeParentFolds unaltered

# Prunes out offspring, grandkids, greatgrandkids (up to X4) steps of
# great ancestors.  It is not automatically recursive across any depth of
# pedigree. That depth works for current test pedigree (IITA 2021).
# Must name parent columns in ped "sireID" and "damID".
makeParentFolds<-function(ped,gid,nrepeats=5,nfolds=5,seed=NULL){
  require(rsample)
  set.seed(seed)
  parentfolds<-rsample::vfold_cv(tibble(Parents=union(ped$sireID,
                                                      ped$damID)),
                                 v = nfolds,repeats = nrepeats) %>%
    mutate(folds=map(splits,function(splits){
      #splits<-parentfolds$splits[[1]]
      testparents<-testing(splits)$Parents
      trainparents<-training(splits)$Parents
      ped<-ped %>%
        rename(gid=!!sym(gid))
      offspring<-ped %>%
        filter(sireID %in% testparents | damID %in% testparents) %$%
        unique(gid)
      grandkids<-ped %>%
        filter(sireID %in% offspring | damID %in% offspring) %$%
        unique(gid)
      greatX1grandkids<-ped %>%
        filter(sireID %in% grandkids | damID %in% grandkids) %$%
        unique(gid)
      greatX2grandkids<-ped %>%
        filter(sireID %in% greatX1grandkids |
                 damID %in% greatX1grandkids) %$%
        unique(gid)
      greatX3grandkids<-ped %>%
        filter(sireID %in% greatX2grandkids |
                 damID %in% greatX2grandkids) %$%
        unique(gid)
      greatX4grandkids<-ped %>%
        filter(sireID %in% greatX3grandkids |
                 damID %in% greatX3grandkids) %$%
        unique(gid)

      testset<-unique(c(offspring,
                        grandkids,
                        greatX1grandkids,
                        greatX2grandkids,
                        greatX3grandkids,
                        greatX4grandkids)) %>%
        .[!. %in% c(testparents,trainparents)]

      nontestdescendents<-ped %>%
        filter(!gid %in% testset) %$%
        unique(gid)
      trainset<-union(testparents,trainparents) %>%
        union(.,nontestdescendents)

      out<-tibble(testparents=list(testparents),
                  trainset=list(trainset),
                  testset=list(testset))
      return(out) })) %>%
    unnest(folds)
  if(nrepeats>1){
    parentfolds %<>%
      rename(Repeat=id,Fold=id2) %>%
      select(-splits)
  }
  if(nrepeats==1){
    parentfolds %<>%
      mutate(Repeat="Repeat1") %>%
      rename(Fold=id) %>%
      select(-splits)
    }


  # Crosses To Predict
  parentfolds %<>%
    mutate(CrossesToPredict=map(testparents,
                                ~filter(ped %>%
                                          # only need a list of fams-to-predict
                                          # not the progeny info
                                          distinct(damID,sireID),
                                        sireID %in% . | damID %in% .)))
  return(parentfolds)
}

```

```{r run makeParentFolds}
parentfolds<-makeParentFolds(ped=ped,gid="GID",
                             nrepeats=nrepeats,
                             nfolds=nfolds,
                             seed=seed)
```

```{r limit number crossestopredict for tests}
# test 1
parentfolds %<>% 
  mutate(CrossesToPredict=map(CrossesToPredict,~slice(.,1:2)))
# test 2?
# parentfolds %<>% 
#   mutate(CrossesToPredict=map(CrossesToPredict,~slice(.,1:3)))
```

## Add DirDom to getMarkEffs 
```{r getMarkEffs}
# markEffs<-getMarkEffs(parentfolds,blups=blups,gid=gid,modelType=modelType,
#                       grms=grms,dosages=dosages,ncores=ncores)
#getMarkEffs<-function(parentfolds,blups,gid,modelType,grms,dosages,ncores){
  
traintestdata<-parentfolds %>%
    dplyr::select(Repeat,Fold,trainset,testset) %>%
    pivot_longer(c(trainset,testset),
                 names_to = "Dataset",
                 values_to = "sampleIDs") %>%
    crossing(Trait=blups$Trait) %>%
    left_join(blups) %>%
    rename(blupsMat=blups)

  ## For each training/testing chunk of sampleIDs and each trait
  ## fit GBLUP model and backsolve SNP-effects
```
```{r funcs from predCrossVar}
getPropHom<-function(M){
  W<-M; W[which(W==2)]<-0;
  # f = 1 − h/N,
  # where N is the number of SNPs
  f<-1-(rowSums(W)/ncol(W))
  return(f)
}
dose2domDevGenotypic<-function(M){
  freq <- colMeans(M,na.rm=T)/2
  P <- matrix(rep(freq,nrow(M)),byrow=T,ncol=ncol(M))
  W<-M; W[which(W==2)]<-0;
  W <- W-(2*P*(1-P))
  return(W)
}
dose2domDev<-function(M){
  freq <- colMeans(M,na.rm=T)/2
  P <- matrix(rep(freq,nrow(M)),byrow=T,ncol=ncol(M))
  W<-M;
  W[which(W==1)]<-2*P[which(W==1)];
  W[which(W==2)]<-(4*P[which(W==2)]-2);
  W <- W-2*(P^2)
  return(W)
}
centerDosage<-function(M){
  freq <- colMeans(M,na.rm=T)/2
  P <- matrix(rep(freq,nrow(M)),byrow=T,ncol=ncol(M))
  Z <- M-2*P
  return(Z)
}

getAF<-function(M){ colMeans(M,na.rm=T)/2 }
getMAF<-function(M){
      freq<-colMeans(M, na.rm=T)/2; maf<-freq;
      maf[which(maf > 0.5)]<-1-maf[which(maf > 0.5)]
      return(maf) }
backsolveSNPeff<-function(Z,g){
      ZZt<-tcrossprod(Z)
      diag(ZZt)<-diag(ZZt)+1e-8
      bslvEffs<-crossprod(Z,solve(ZZt))%*%g
      return(bslvEffs)
}
```

### Detour to compare models

**Compare classic-genotypic-dirdom models**

```{r}
RhpcBLASctl::blas_set_num_threads(56)

Dclassic<-readRDS(file=here::here("output","kinship_D_IITA_2021May13.rds"))
sampleIDs<-traintestdata$sampleIDs[[2]]; blupsMat<-traintestdata$blupsMat[[2]]
A<-grms[["A"]]
D<-grms[["D"]]

trainingdata<-blupsMat %>%
  dplyr::rename(gid=!!sym(gid)) %>%
  filter(gid %in% sampleIDs)
trainingdata[[paste0(gid,"a")]]<-factor(trainingdata[["gid"]],
                                        levels=rownames(A))
trainingdata[[paste0(gid,"d")]]<-trainingdata[[paste0(gid,"a")]] 
trainingdata[[paste0(gid,"d_star")]]<-trainingdata[[paste0(gid,"a")]] 
f<-getPropHom(dosages)
trainingdata %<>% mutate(f=f[trainingdata$gid])
require(sommer)

fit_dirdom <- sommer::mmer(fixed = drgBLUP ~1+f,
                           random = as.formula(paste0("~vs(",gid,"a,Gu=A)+vs(",gid,"d_star,Gu=D)")),
                           weights = WT,
                           data=trainingdata,
                           date.warning = F)
fit_geno <- sommer::mmer(fixed = drgBLUP ~1,
                         random = as.formula(paste0("~vs(",gid,"a,Gu=A)+vs(",gid,"d_star,Gu=D)")),
                         weights = WT,
                         data=trainingdata,
                         date.warning = F)
fit_classic <- sommer::mmer(fixed = drgBLUP ~1,
                            random = as.formula(paste0("~vs(",gid,"a,Gu=A)+vs(",gid,"d_star,Gu=Dclassic)")),
                            weights = WT,
                            data=trainingdata,
                            date.warning = F)
summary(fit_classic)
#        logLik      AIC      BIC Method Converge
# Value -1321.737 2645.474 2651.553     NR     TRUE
# =============================================================
# Variance-Covariance components:
#                             VarComp VarCompSE Zratio Constraint
# u:GIDa.drgBLUP-drgBLUP      0.01470  0.004259  3.450   Positive
# u:GIDd_star.drgBLUP-drgBLUP 0.02138  0.005596  3.821   Positive
# units.drgBLUP-drgBLUP       0.44553  0.013963 31.908   Positive

summary(fit_geno)
#         logLik      AIC      BIC Method Converge
# Value -1327.431 2656.863 2662.942     NR     TRUE
# =============================================================
# Variance-Covariance components:
#                             VarComp VarCompSE Zratio Constraint
# u:GIDa.drgBLUP-drgBLUP      0.01127  0.005215  2.160   Positive
# u:GIDd_star.drgBLUP-drgBLUP 0.02190  0.006840  3.202   Positive
# units.drgBLUP-drgBLUP       0.45341  0.013693 33.112   Positive

summary(fit_dirdom)

#          logLik      AIC      BIC Method Converge
# Value -1314.438 2632.876 2645.035     NR     TRUE
# =============================================================
# Variance-Covariance components:
#                              VarComp VarCompSE Zratio Constraint
# u:GIDa.drgBLUP-drgBLUP      0.016243  0.005295  3.068   Positive
# u:GIDd_star.drgBLUP-drgBLUP 0.009901  0.005968  1.659   Positive
# units.drgBLUP-drgBLUP       0.460633  0.013617 33.829   Positive
# =============================================================
# Fixed effects:
#     Trait      Effect Estimate Std.Error t.value
# 1 drgBLUP (Intercept)    1.844    0.3130   5.890
# 2 drgBLUP           f   -2.604    0.4636  -5.616
```
Surprisingly, the dirdom has lowest AIC, highest logLik
```{r}
# Start comparing classic-to-genotypic (no dir. dom)
## Their predicted GETGV should be same

tibble(GID=as.character(names(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP)),
       GEBV=as.numeric(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP),
       GEDD=as.numeric(fit_classic$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
  mutate(GETGV_classic=GEBV+GEDD) %>% 
  left_join(tibble(GID=as.character(names(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEadd=as.numeric(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP),
                   GEdom=as.numeric(fit_geno$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
              mutate(GETGV_geno=GEadd+GEdom)) %>% 
  dplyr::select(-GID) %>% 
  cor(x = .) %>% round(.,2)
#               GEBV GEDD GETGV_classic GEadd GEdom GETGV_geno
# GEBV          1.00 0.06          0.71  0.96  0.41       0.79
# GEDD          0.06 1.00          0.75  0.04  0.84       0.62
# GETGV_classic 0.71 0.75          1.00  0.67  0.87       0.97
# GEadd         0.96 0.04          0.67  1.00  0.30       0.73
# GEdom         0.41 0.84          0.87  0.30  1.00       0.87
# GETGV_geno    0.79 0.62          0.97  0.73  0.87       1.00
```

GETGV_geno and GETGV_classic aren't identical but cor=0.97

GEBV and GEDD from classic are not cor., which is good and (expected?)

GEadd and GEdom are more strongly cor, cor=0.3

GEadd _and_ GEdo are corr. to GEBV (from classic model).


Next, look at marker effects: the classic alpha effects should match the reconstitute alpha from the geno model (alpha = a+d(q-p))

```{r}
M<-centerDosage(dosages)
domdevMat_classic<-dose2domDev(dosages)
alpha_classic<-backsolveSNPeff(Z=M,
                               g=as.matrix(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)) 
domdev_classic<-backsolveSNPeff(Z=domdevMat_classic,
                                g=as.matrix(fit_classic$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1))

addsnpeff_geno<-backsolveSNPeff(Z=M,
                                g=as.matrix(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)) 
domdevMat_genotypic<-dose2domDevGenotypic(dosages)
domsnpeff_geno<-backsolveSNPeff(Z=domdevMat_genotypic,
                                g=as.matrix(fit_geno$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1))

p<-getAF(dosages)
q<-1-p
alpha_geno<-addsnpeff_geno+(domsnpeff_geno*(q-p))

cor(alpha_geno,alpha_classic)  
#           [,1]
# [1,] 0.819733
```
I was expecting more than a 0.82 since GETGV cors were higher. 

So how cor. are the GEBV_classic to the GEBV_geno from multiplying dosages vs. alpha_geno?

```{r}
gebv_geno<-M%*%alpha_geno

tibble(GID=as.character(names(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP)),
       GEBV=as.numeric(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP),
       GEDD=as.numeric(fit_classic$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
  mutate(GETGV_classic=GEBV+GEDD) %>% 
  left_join(tibble(GID=as.character(names(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEadd=as.numeric(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP),
                   GEdom=as.numeric(fit_geno$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
              mutate(GETGV_geno=GEadd+GEdom)) %>% 
  left_join(tibble(GID=rownames(gebv_geno),GEBV_geno=as.numeric(gebv_geno))) %>% 
  dplyr::select(-GID) %>% 
  cor(x = .) %>% round(.,2)
#               GEBV GEDD GETGV_classic GEadd GEdom GETGV_geno GEBV_geno
# GEBV          1.00 0.06          0.71  0.96  0.41       0.79      0.98
# GEDD          0.06 1.00          0.75  0.04  0.84       0.62      0.08
# GETGV_classic 0.71 0.75          1.00  0.67  0.87       0.97      0.71
# GEadd         0.96 0.04          0.67  1.00  0.30       0.73      0.92
# GEdom         0.41 0.84          0.87  0.30  1.00       0.87      0.49
# GETGV_geno    0.79 0.62          0.97  0.73  0.87       1.00      0.82
# GEBV_geno     0.98 0.08          0.71  0.92  0.49       0.82      1.00
```

The above is comforting.

GEBV_geno and GEBV_classic have cor=0.98. 

Marker effects vectors might have lower corr. but the result predicted individual values (BV and TGV) match up.

**Should they have been identical?**

So finally, below, compare the dirdom results: both dom-effects, alpha-effects and the GEBV/GETGV
```{r}
addsnpeff_dirdom<-backsolveSNPeff(Z=M,
                                  g=as.matrix(fit_dirdom$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)) 
domstar_snpeff_dirdom<-backsolveSNPeff(Z=domdevMat_genotypic,
                                  g=as.matrix(fit_dirdom$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1))
b<-fit_dirdom$Beta[fit_dirdom$Beta$Effect=="f","Estimate"]
domsnpeff_dirdom<-domstar_snpeff_dirdom-(b/length(domstar_snpeff_dirdom))
alpha_dirdom<-addsnpeff_dirdom+(domsnpeff_dirdom*(q-p))

tibble(d_dirdom=domsnpeff_dirdom,
       d_classic=domdev_classic,
       alpha_dirdom=alpha_dirdom,
       alpha_classic=alpha_classic,
       alpha_geno=alpha_geno) %>% 
  cor(.) %>% round(.,2)
#               d_dirdom d_classic alpha_dirdom alpha_classic alpha_geno
# d_dirdom          1.00      0.85         0.25          0.18       0.34
# d_classic         0.85      1.00         0.04         -0.02       0.14
# alpha_dirdom      0.25      0.04         1.00          0.87       0.90
# alpha_classic     0.18     -0.02         0.87          1.00       0.82
# alpha_geno        0.34      0.14         0.90          0.82       1.00
```
alpha_class and alpha_dirdom effects are actually better cor. than 
alpha_classic-alpha_geno.

Next, look at the GEBV/GETGV

```{r}
gebv_dirdom<-M%*%alpha_dirdom
gedomval_dirdom<-domdevMat_genotypic%*%domsnpeff_dirdom
      
tibble(GID=as.character(names(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP)),
       GEBV=as.numeric(fit_classic$U[[paste0("u:",gid,"a")]]$drgBLUP),
       GEDD=as.numeric(fit_classic$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
  mutate(GETGV_classic=GEBV+GEDD) %>% 
  left_join(tibble(GID=as.character(names(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEadd=as.numeric(fit_geno$U[[paste0("u:",gid,"a")]]$drgBLUP),
                   GEdom=as.numeric(fit_geno$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
              mutate(GETGV_geno=GEadd+GEdom)) %>% 
  left_join(tibble(GID=rownames(gebv_geno),GEBV_geno=as.numeric(gebv_geno))) %>% 
  left_join(tibble(GID=as.character(names(fit_dirdom$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEa_dirdom=as.numeric(fit_dirdom$U[[paste0("u:",gid,"a")]]$drgBLUP),
                   GEd_dirdom=as.numeric(gedomval_dirdom),
                   GETGV_dirdom=GEa_dirdom+GEd_dirdom,
                   GEBV_dirdom=as.numeric(gebv_dirdom))) -> gblups_to_cor
gblups_to_cor %>% 
  dplyr::select(-GID,-GEa_dirdom,-GEd_dirdom,-GEadd,-GEdom,-GEDD) %>% 
  cor(x = .) %>% round(.,2)
#               GEBV GETGV_classic GETGV_geno GEBV_geno GETGV_dirdom GEBV_dirdom
# GEBV          1.00          0.71       0.79      0.98         0.66        0.98
# GETGV_classic 0.71          1.00       0.97      0.71         0.91        0.71
# GETGV_geno    0.79          0.97       1.00      0.82         0.92        0.81
# GEBV_geno     0.98          0.71       0.82      1.00         0.69        0.99
# GETGV_dirdom  0.66          0.91       0.92      0.69         1.00        0.70
# GEBV_dirdom   0.98          0.71       0.81      0.99         0.70        1.00

gblups_to_cor %>% 
  dplyr::select(GEDD,GEdom,GEd_dirdom) %>% 
  cor(x = .) %>% round(.,2)
#            GEDD GEdom GEd_dirdom
# GEDD       1.00  0.84       0.81
# GEdom      0.84  1.00       0.82
# GEd_dirdom 0.81  0.82       1.00
```


### Back on track - adding DirDom to fitModel

```{r fitModel - in getMarkEffs}
#fitModel<-function(sampleIDs,blupsMat,modelType,gid,grms,dosages,...){
    # debug
    sampleIDs<-traintestdata$sampleIDs[[2]]; blupsMat<-traintestdata$blupsMat[[2]]
    # DELETE THIS REQ for predCrossVar???? 
    # require(predCrossVar)
    
    A<-grms[["A"]]
    if(modelType %in% c("AD","DirDom")){ D<-grms[["D"]] }
    
    trainingdata<-blupsMat %>%
      dplyr::rename(gid=!!sym(gid)) %>%
      filter(gid %in% sampleIDs)
    
    trainingdata[[paste0(gid,"a")]]<-factor(trainingdata[["gid"]],
                                            levels=rownames(A))
    if(modelType %in% c("AD")){
      trainingdata[[paste0(gid,"d")]]<-trainingdata[[paste0(gid,"a")]] }
    if(modelType %in% c("DirDom")){
      trainingdata[[paste0(gid,"d_star")]]<-trainingdata[[paste0(gid,"a")]] }
    
    # Set-up random model statements
    randFormula<-paste0("~vs(",gid,"a,Gu=A)")
    if(modelType %in% c("AD")){
      randFormula<-paste0(randFormula,"+vs(",gid,"d,Gu=D)") }
    if(modelType=="DirDom"){  
      randFormula<-paste0(randFormula,"+vs(",gid,"d_star,Gu=D)")
      f<-getPropHom(dosages)
      trainingdata %<>% mutate(f=f[trainingdata$gid]) }
    
    # Fixed model statements
    fixedFomula<-ifelse(modelType=="DirDom",
                        "drgBLUP ~1+f","drgBLUP ~1")
    # Fit genomic prediction model
    require(sommer)
    fit <- sommer::mmer(fixed = as.formula(fixedFomula),
                        random = as.formula(randFormula),
                        weights = WT,
                        data=trainingdata,
                        date.warning = F)
```


```{r backsolve SNP effects - in fitModel}
# Backsolve SNP effects
    # Compute allele sub effects
    ## Every model has an additive random term
    ga<-as.matrix(fit$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)
    M<-centerDosage(dosages)
    
    if(modelType %in% c("A","AD")){  
      # models A and AD give add effects corresponding to allele sub effects
      allelesubsnpeff<-backsolveSNPeff(Z=M,g=ga) }
    
    if(modelType %in% c("AD")){
      # model AD the dom effects are dominance deviation effects
      gd<-as.matrix(fit$U[[paste0("u:",gid,"d")]]$drgBLUP,ncol=1)
      domdevsnpeff<-backsolveSNPeff(Z=dose2domDev(dosages),g=gd) }
    
    if(modelType %in% c("DirDom")){
      # model DirDom is a different add-dom partition, 
      ### add effects are not allele sub effects and gblups are not GEBV
      addsnpeff<-backsolveSNPeff(Z=M,g=ga) 
      ### dom effects are called d*, gd_star or domstar 
      ### because of the genome-wide homoz. term included in model
      gd_star<-as.matrix(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1)
      domdevMat_genotypic<-dose2domDevGenotypic(dosages)
      domstar_snpeff<-backsolveSNPeff(Z=domdevMat_genotypic,g=gd_star)
      ### b = the estimate (BLUE) for the genome-wide homoz. effect
      b<-fit$Beta[fit$Beta$Effect=="f","Estimate"]
      ### calc. domsnpeff including the genome-wide homoz. effect
      ### divide the b effect up by number of SNPs and _subtract_ from domstar
      domsnpeff<-domstar_snpeff-(b/length(domstar_snpeff))

      ### allele substitution effects using a+d(q-p) where d=d*-b/p
      p<-getAF(dosages)
      q<-1-p
      allelesubsnpeff<-addsnpeff+(domsnpeff*(q-p))
    }
```

```{r gather GBLUPs - in fitModel}
# Gather the GBLUPs
if(modelType==c("A","AD")){ 
  gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                 GEBV=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)) }
if(modelType %in% c("AD")){ 
  gblups %<>% # compute GEDD (genomic-estimated dominance deviation)
    mutate(GEDD=as.numeric(fit$U[[paste0("u:",gid,"d")]]$drgBLUP)) }
if(modelType==c("A","AD")){ # compute GETGV
  ## Note that for modelType=="A", GEBV==GETGV
  gblups %<>% mutate(GETGV=rowSums(.[,grepl("GE",colnames(.))])) }
if(modelType %in% c("DirDom")){ 
  # re-calc the GBLUP, GEdomval using dom. effects where d=d*-b/p
  ge_domval<-domdevMat_genotypic%*%domsnpeff
  # calc. the GEBV using allele sub. effects where alpha=a+d(p-q), and d=d*-b/p
  gebv<-M%*%allelesubsnpeff
  # Tidy tibble of GBLUPs
  gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                 GEadd=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP),
                 GEdom_star=as.numeric(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
    left_join(tibble(GID=rownames(ge_domval),GEdomval=as.numeric(ge_domval))) %>% 
    left_join(tibble(GID=rownames(gebv),GEdomval=as.numeric(gebv))) %>% 
    # GETGV from GEadd + GEdomval
    mutate(GETGV=GEadd+GEdomval)
}
```


```{r extract and tidy outputs - in fitModel}
# Extract variance components
varcomps<-summary(fit)$varcomp

# Exract fixed effects
# for modelType="DirDom", contains estimate of genome-wide homoz. effect
fixeffs<-summary(fit)$betas

results<-tibble(gblups=list(gblups),
                varcomps=list(varcomps),
                fixeffs=list(fixeffs))
# Add snpeffects to output
results %<>% mutate(allelesubsnpeff=list(allelesubsnpeff)) 
if(modelType=="AD"){ results %<>% mutate(domdevsnpeff=list(domdevsnpeff)) }
if(modelType=="DirDom"){ 
  results %<>% mutate(addsnpeff=list(addsnpeff),
                      domstar_snpeff=list(domstar_snpeff),
                      domsnpeff=list(domsnpeff)) }
    # return results
    return(results)
#  }
```

### Testing fitModel with DirDom

Restart the rsession, re-run the "Initial Steps"

```{r fitModel - tested above}
fitModel<-function(sampleIDs,blupsMat,modelType,gid,grms,dosages,...){
  # debug
  # sampleIDs<-traintestdata$sampleIDs[[2]]; blupsMat<-traintestdata$blupsMat[[2]]
  
  A<-grms[["A"]]
  if(modelType %in% c("AD","DirDom")){ D<-grms[["D"]] }
  
  trainingdata<-blupsMat %>%
    dplyr::rename(gid=!!sym(gid)) %>%
    filter(gid %in% sampleIDs)
  
  trainingdata[[paste0(gid,"a")]]<-factor(trainingdata[["gid"]],
                                          levels=rownames(A))
  if(modelType %in% c("AD")){
    trainingdata[[paste0(gid,"d")]]<-trainingdata[[paste0(gid,"a")]] }
  if(modelType %in% c("DirDom")){
    trainingdata[[paste0(gid,"d_star")]]<-trainingdata[[paste0(gid,"a")]] }
  
  # Set-up random model statements
  randFormula<-paste0("~vs(",gid,"a,Gu=A)")
  if(modelType %in% c("AD")){
    randFormula<-paste0(randFormula,"+vs(",gid,"d,Gu=D)") }
  if(modelType=="DirDom"){  
    randFormula<-paste0(randFormula,"+vs(",gid,"d_star,Gu=D)")
    f<-getPropHom(dosages)
    trainingdata %<>% mutate(f=f[trainingdata$gid]) }
  
  # Fixed model statements
  fixedFomula<-ifelse(modelType=="DirDom",
                      "drgBLUP ~1+f","drgBLUP ~1")
  # Fit genomic prediction model
  require(sommer)
  fit <- sommer::mmer(fixed = as.formula(fixedFomula),
                      random = as.formula(randFormula),
                      weights = WT,
                      data=trainingdata,
                      date.warning = F)
  
  # Backsolve SNP effects
  # Compute allele sub effects
  ## Every model has an additive random term
  ga<-as.matrix(fit$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)
  M<-centerDosage(dosages)
  
  if(modelType %in% c("A","AD")){  
    # models A and AD give add effects corresponding to allele sub effects
    allelesubsnpeff<-backsolveSNPeff(Z=M,g=ga) }
  
  if(modelType %in% c("AD")){
    # model AD the dom effects are dominance deviation effects
    gd<-as.matrix(fit$U[[paste0("u:",gid,"d")]]$drgBLUP,ncol=1)
    domdevsnpeff<-backsolveSNPeff(Z=dose2domDev(dosages),g=gd) }
  
  if(modelType %in% c("DirDom")){
    # model DirDom is a different add-dom partition, 
    ### add effects are not allele sub effects and gblups are not GEBV
    addsnpeff<-backsolveSNPeff(Z=M,g=ga) 
    ### dom effects are called d*, gd_star or domstar 
    ### because of the genome-wide homoz. term included in model
    gd_star<-as.matrix(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1)
    domdevMat_genotypic<-dose2domDevGenotypic(dosages)
    domstar_snpeff<-backsolveSNPeff(Z=domdevMat_genotypic,g=gd_star)
    ### b = the estimate (BLUE) for the genome-wide homoz. effect
    b<-fit$Beta[fit$Beta$Effect=="f","Estimate"]
    ### calc. domsnpeff including the genome-wide homoz. effect
    ### divide the b effect up by number of SNPs and _subtract_ from domstar
    domsnpeff<-domstar_snpeff-(b/length(domstar_snpeff))
    
    ### allele substitution effects using a+d(q-p) where d=d*-b/p
    p<-getAF(dosages)
    q<-1-p
    allelesubsnpeff<-addsnpeff+(domsnpeff*(q-p))
  }
  
  # Gather the GBLUPs
  if(modelType==c("A","AD")){ 
    gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEBV=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)) }
  if(modelType %in% c("AD")){ 
    gblups %<>% # compute GEDD (genomic-estimated dominance deviation)
      mutate(GEDD=as.numeric(fit$U[[paste0("u:",gid,"d")]]$drgBLUP)) }
  if(modelType==c("A","AD")){ # compute GETGV
    ## Note that for modelType=="A", GEBV==GETGV
    gblups %<>% mutate(GETGV=rowSums(.[,grepl("GE",colnames(.))])) }
  if(modelType %in% c("DirDom")){ 
    # re-calc the GBLUP, GEdomval using dom. effects where d=d*-b/p
    ge_domval<-domdevMat_genotypic%*%domsnpeff
    # calc. the GEBV using allele sub. effects where alpha=a+d(p-q), and d=d*-b/p
    gebv<-M%*%allelesubsnpeff
    # Tidy tibble of GBLUPs
    gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                   GEadd=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP),
                   GEdom_star=as.numeric(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
      left_join(tibble(GID=rownames(ge_domval),GEdomval=as.numeric(ge_domval))) %>% 
      left_join(tibble(GID=rownames(gebv),GEdomval=as.numeric(gebv))) %>% 
      # GETGV from GEadd + GEdomval
      mutate(GETGV=GEadd+GEdomval)
  }
  
  # Extract variance components
  varcomps<-summary(fit)$varcomp
  
  # Exract fixed effects
  # for modelType="DirDom", contains estimate of genome-wide homoz. effect
  fixeffs<-summary(fit)$betas
  
  results<-tibble(gblups=list(gblups),
                  varcomps=list(varcomps),
                  fixeffs=list(fixeffs))
  # Add snpeffects to output
  results %<>% mutate(allelesubsnpeff=list(allelesubsnpeff)) 
  if(modelType=="AD"){ results %<>% mutate(domdevsnpeff=list(domdevsnpeff)) }
  if(modelType=="DirDom"){ 
    results %<>% mutate(addsnpeff=list(addsnpeff),
                        domstar_snpeff=list(domstar_snpeff),
                        domsnpeff=list(domsnpeff)) }
   # this is to remove conflicts with dplyr function select() downstream
  detach("package:sommer",unload = T); detach("package:MASS",unload = T)

  # return results
  return(results)
}
```
```{r}
# sampleIDs<-traintestdata$sampleIDs[[1]]; blupsMat<-traintestdata$blupsMat[[1]];
# test<-fitModel(sampleIDs,blupsMat,modelType,gid,grms,dosages)
# rm(sampleIDs,blupsMat)
```


```{r run fitModel - in getMarkEffs}
require(furrr); plan(multicore, workers = ncores)
options(future.globals.maxSize=+Inf)
options(future.rng.onMisuse="ignore")
traintestdata<-traintestdata %>%
  mutate(modelOut=future_pmap(.,fitModel,
                              modelType=modelType,
                              gid=gid,
                              grms=grms,
                              dosages=dosages),
         modelType=modelType)
  # this is to remove conflicts with dplyr function select() downstream
  detach("package:sommer",unload = T); detach("package:MASS",unload = T)

traintestdata %<>%
  select(-blupsMat,-sampleIDs) %>%
  unnest(modelOut) %>%
  nest(effects=c(-Repeat,-Fold,-Dataset,-modelType))

  return(traintestdata)
#}
```

### getMarkEffs - includes DirDom 
```{r func TO ADD TO parentWiseCrossVal.R}
getMarkEffs<-function(parentfolds,blups,gid,modelType,grms,dosages,ncores){
  
  traintestdata<-parentfolds %>%
    dplyr::select(Repeat,Fold,trainset,testset) %>%
    pivot_longer(c(trainset,testset),
                 names_to = "Dataset",
                 values_to = "sampleIDs") %>%
    crossing(Trait=blups$Trait) %>%
    left_join(blups) %>%
    rename(blupsMat=blups)
  
  fitModel<-function(sampleIDs,blupsMat,modelType,gid,grms,dosages,...){
    # debug
    # sampleIDs<-traintestdata$sampleIDs[[2]]; blupsMat<-traintestdata$blupsMat[[2]]
    
    A<-grms[["A"]]
    if(modelType %in% c("AD","DirDom")){ D<-grms[["D"]] }
    
    trainingdata<-blupsMat %>%
      dplyr::rename(gid=!!sym(gid)) %>%
      filter(gid %in% sampleIDs)
    
    trainingdata[[paste0(gid,"a")]]<-factor(trainingdata[["gid"]],
                                            levels=rownames(A))
    if(modelType %in% c("AD")){
      trainingdata[[paste0(gid,"d")]]<-trainingdata[[paste0(gid,"a")]] }
    if(modelType %in% c("DirDom")){
      trainingdata[[paste0(gid,"d_star")]]<-trainingdata[[paste0(gid,"a")]] }
    
    # Set-up random model statements
    randFormula<-paste0("~vs(",gid,"a,Gu=A)")
    if(modelType %in% c("AD")){
      randFormula<-paste0(randFormula,"+vs(",gid,"d,Gu=D)") }
    if(modelType=="DirDom"){  
      randFormula<-paste0(randFormula,"+vs(",gid,"d_star,Gu=D)")
      f<-getPropHom(dosages)
      trainingdata %<>% mutate(f=f[trainingdata$gid]) }
    
    # Fixed model statements
    fixedFomula<-ifelse(modelType=="DirDom",
                        "drgBLUP ~1+f","drgBLUP ~1")
    # Fit genomic prediction model
    require(sommer)
    fit <- sommer::mmer(fixed = as.formula(fixedFomula),
                        random = as.formula(randFormula),
                        weights = WT,
                        data=trainingdata,
                        date.warning = F)
    
    # Backsolve SNP effects
    # Compute allele sub effects
    ## Every model has an additive random term
    ga<-as.matrix(fit$U[[paste0("u:",gid,"a")]]$drgBLUP,ncol=1)
    M<-centerDosage(dosages)
    
    if(modelType %in% c("A","AD")){  
      # models A and AD give add effects corresponding to allele sub effects
      allelesubsnpeff<-backsolveSNPeff(Z=M,g=ga) }
    
    if(modelType %in% c("AD")){
      # model AD the dom effects are dominance deviation effects
      gd<-as.matrix(fit$U[[paste0("u:",gid,"d")]]$drgBLUP,ncol=1)
      domdevsnpeff<-backsolveSNPeff(Z=dose2domDev(dosages),g=gd) }
    
    if(modelType %in% c("DirDom")){
      # model DirDom is a different add-dom partition, 
      ### add effects are not allele sub effects and gblups are not GEBV
      addsnpeff<-backsolveSNPeff(Z=M,g=ga) 
      ### dom effects are called d*, gd_star or domstar 
      ### because of the genome-wide homoz. term included in model
      gd_star<-as.matrix(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP,ncol=1)
      domdevMat_genotypic<-dose2domDevGenotypic(dosages)
      domstar_snpeff<-backsolveSNPeff(Z=domdevMat_genotypic,g=gd_star)
      ### b = the estimate (BLUE) for the genome-wide homoz. effect
      b<-fit$Beta[fit$Beta$Effect=="f","Estimate"]
      ### calc. domsnpeff including the genome-wide homoz. effect
      ### divide the b effect up by number of SNPs and _subtract_ from domstar
      domsnpeff<-domstar_snpeff-(b/length(domstar_snpeff))
      
      ### allele substitution effects using a+d(q-p) where d=d*-b/p
      p<-getAF(dosages)
      q<-1-p
      allelesubsnpeff<-addsnpeff+(domsnpeff*(q-p))
    }
    
    # Gather the GBLUPs
    if(modelType %in% c("A","AD")){ 
      gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                     GEBV=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)) }
    if(modelType=="AD"){ 
      gblups %<>% # compute GEDD (genomic-estimated dominance deviation)
        mutate(GEDD=as.numeric(fit$U[[paste0("u:",gid,"d")]]$drgBLUP),
               # compute GETGV
               GETGV=rowSums(.[,grepl("GE",colnames(.))])) }
    if(modelType=="DirDom"){ 
      # re-calc the GBLUP, GEdomval using dom. effects where d=d*-b/p
      ge_domval<-domdevMat_genotypic%*%domsnpeff
      # calc. the GEBV using allele sub. effects where alpha=a+d(p-q), and d=d*-b/p
      gebv<-M%*%allelesubsnpeff
      # Tidy tibble of GBLUPs
      gblups<-tibble(GID=as.character(names(fit$U[[paste0("u:",gid,"a")]]$drgBLUP)),
                     GEadd=as.numeric(fit$U[[paste0("u:",gid,"a")]]$drgBLUP),
                     GEdom_star=as.numeric(fit$U[[paste0("u:",gid,"d_star")]]$drgBLUP)) %>% 
        left_join(tibble(GID=rownames(ge_domval),GEdomval=as.numeric(ge_domval))) %>% 
        left_join(tibble(GID=rownames(gebv),GEBV=as.numeric(gebv))) %>% 
        # GETGV from GEadd + GEdomval
        mutate(GETGV=GEadd+GEdomval)
    }
    
    # Extract variance components
    varcomps<-summary(fit)$varcomp
    
    # Exract fixed effects
    # for modelType="DirDom", contains estimate of genome-wide homoz. effect
    fixeffs<-summary(fit)$betas
    
    results<-tibble(gblups=list(gblups),
                    varcomps=list(varcomps),
                    fixeffs=list(fixeffs))
    # Add snpeffects to output
    results %<>% mutate(allelesubsnpeff=list(allelesubsnpeff)) 
    if(modelType=="AD"){ results %<>% mutate(domdevsnpeff=list(domdevsnpeff)) }
    if(modelType=="DirDom"){ 
      results %<>% mutate(addsnpeff=list(addsnpeff),
                          domstar_snpeff=list(domstar_snpeff),
                          domsnpeff=list(domsnpeff)) }
    # this is to remove conflicts with dplyr function select() downstream
    detach("package:sommer",unload = T); detach("package:MASS",unload = T)
    
    # return results
    return(results)
  }
  
  require(furrr); plan(multicore, workers = ncores)
  options(future.globals.maxSize=+Inf); options(future.rng.onMisuse="ignore")
  traintestdata<-traintestdata %>%
    mutate(modelOut=future_pmap(.,fitModel,
                                modelType=modelType,
                                gid=gid,
                                grms=grms,
                                dosages=dosages),
           modelType=modelType)
  # this is to remove conflicts with dplyr function select() downstream
  detach("package:sommer",unload = T); detach("package:MASS",unload = T)
  
  traintestdata %<>%
    select(-blupsMat,-sampleIDs) %>%
    unnest(modelOut) %>%
    nest(effects=c(-Repeat,-Fold,-Dataset,-modelType))
  
  return(traintestdata)
}
```

## Add DirDom to predictCrossVars
```{r input for testing}
snpeffs=traintestdata
source(here::here("code","predCrossVar.R"))
```

```{r predictCrossVars func TO ADD TO parentWiseCrossVal.R}
predictCrossVars<-function(modelType,snpeffs,parentfolds,
                           haploMat,recombFreqMat,ncores){
predvars<-snpeffs %>%
  unnest(effects) %>%
  filter(Dataset=="trainset") %>%
  dplyr::select(Repeat,Fold,Trait,modelType,contains("snpeff")) %>% 
  nest(EffectList=c(Trait,contains("snpeff"))) %>%
  # AlleleSubEffects to predict VarBV for all models
  mutate(AlleleSubEffectList=map(EffectList,
                                 function(EffectList){
                                   allelesubsnpeff<-map(EffectList$allelesubsnpeff,~t(.))
                                   names(allelesubsnpeff)<-EffectList$Trait
                                   return(allelesubsnpeff)}))
if(modelType=="AD"){
  predvars<-predvars %>%
    # DomDevEffects for model "AD" to predict VarTGV = VarBV + VarDD
    mutate(DomDevEffectList=map(EffectList,
                             function(EffectList){
                               domdevsnpeff<-map(EffectList$domdevsnpeff,~t(.))
                               names(domdevsnpeff)<-EffectList$Trait
                               return(domdevsnpeff) })) }
if(modelType=="DirDom"){
  predvars<-predvars %>%
    # AddEffectList + DomEffectList --> VarTGV; AlleleSubEffectList --> VarBV;
    mutate(AddEffectList=map(EffectList,
                             function(EffectList){
                               addsnpeff<-map(EffectList$addsnpeff,~t(.))
                               names(addsnpeff)<-EffectList$Trait
                               return(addsnpeff) }),
           DomEffectList=map(EffectList,
                             function(EffectList){
                               domsnpeff<-map(EffectList$domsnpeff,~t(.))
                               names(domsnpeff)<-EffectList$Trait
                               return(domsnpeff) })) }
predvars %<>%
  left_join(parentfolds %>%
              dplyr::select(-testparents,-trainset,-testset)) %>%
  dplyr::select(-EffectList)

require(furrr); 
options(future.globals.maxSize=+Inf); options(future.rng.onMisuse="ignore")


  if(modelType=="A"){
    predvars<-predvars %>%
      mutate(predVars=map2(CrossesToPredict,AlleleSubEffectList,
                           ~predCrossVars(CrossesToPredict=.x,
                                          AddEffectList=.y,
                                          modelType=modelType,
                                          haploMat=haploMat,
                                          recombFreqMat=recombFreqMat,
                                          ncores=ncores) %>% 
                             unnest(predVars) %>% 
                             mutate(predOf="VarBV") %>% 
                             nest(predVars=c(Trait1,Trait2,predOf,predVar)))) }
  if(modelType=="AD"){
    predvars<-predvars %>%
      mutate(predVars=pmap(.,function(CrossesToPredict,
                                      AlleleSubEffectList,
                                      DomDevEffectList,...){
        out<-predCrossVars(CrossesToPredict=CrossesToPredict,
                           AddEffectList=AlleleSubEffectList,
                           DomEffectList=DomDevEffectList,
                           modelType=modelType,
                           haploMat=haploMat,
                           recombFreqMat=recombFreqMat,
                           ncores=ncores)
        out<-out %>% 
          unnest(predVars) %>% 
          mutate(predOf=ifelse(predOf=="VarA","VarBV","VarDD")) %>% 
          nest(predVars=c(Trait1,Trait2,predOf,predVar))
        return(out) })) }
  if(modelType=="DirDom"){
    predvars<-predvars %>%
      mutate(predVars=pmap(.,function(CrossesToPredict,
                                      AlleleSubEffectList,
                                      AddEffectList,
                                      DomEffectList,...){
        # debug -----
        # CrossesToPredict<-predvars$CrossesToPredict[[1]]
        # AddEffectList<-predvars$AddEffectList[[1]]
        # DomEffectList<-predvars$DomEffectList[[1]]
        # AlleleSubEffectList<-predvars$AlleleSubEffectList[[1]]
        predVarTGV<-predCrossVars(CrossesToPredict=CrossesToPredict,
                           AddEffectList=AddEffectList,
                           DomEffectList=DomEffectList,
                           modelType="AD", # no "DirDom" model in predCrossVars() nor is it needed
                           haploMat=haploMat,
                           recombFreqMat=recombFreqMat,
                           ncores=ncores)
        predVarBV<-predCrossVars(CrossesToPredict=CrossesToPredict,
                                 AddEffectList=AlleleSubEffectList,
                                 DomEffectList=NULL,
                                 modelType="A", # no "DirDom" model in predCrossVars() nor is it needed
                                 haploMat=haploMat,
                                 recombFreqMat=recombFreqMat,
                                 ncores=ncores)
        out<-predVarBV %>% 
          unnest(predVars) %>% 
          mutate(predOf="VarBV") %>% 
          bind_rows(predVarTGV %>% 
                      unnest(predVars)) %>% 
          nest(predVars=c(Trait1,Trait2,predOf,predVar))
        return(out) })) }
  predvars %<>% select(-contains("EffectList"),-CrossesToPredict)
  return(predvars)
}

```
```{r call to predictCrossVars func}
# cvPredVars<-predictCrossVars(modelType=modelType,ncores=ncores,
#                                snpeffs=markEffs,
#                                parentfolds=parentfolds,
#                                haploMat=haploMat,
#                                recombFreqMat=recombFreqMat)
```

## Add DirDom to predictCrossMeans
```{r input for testing}
doseMat=dosages
```
```{r predictCrossMeans func TO ADD TO parentWiseCrossVal.R}
predictCrossMeans<-function(modelType,snpeffs,parentfolds,
                            doseMat,ncores){
  predmeans<-snpeffs %>%
    unnest(effects) %>%
    filter(Dataset=="trainset") %>%
    dplyr::select(Repeat,Fold,Trait,modelType,contains("snpeff")) %>% 
    nest(EffectList=c(Trait,contains("snpeff"))) %>%
    # AlleleSubEffects are available from all prediction models
    ## therefore, prediction of MeanBV is available for all models
    mutate(AlleleSubEffectList=map(EffectList,
                                   function(EffectList){
                                     allelesubsnpeff<-map(EffectList$allelesubsnpeff,~t(.))
                                     names(allelesubsnpeff)<-EffectList$Trait
                                     return(allelesubsnpeff)})) %>% 
    left_join(parentfolds %>%
                dplyr::select(-testparents,-trainset,-testset))
  
  ## predict MeanBVs
  predmeans %<>%
    mutate(predMeans=pmap(.,function(AlleleSubEffectList,CrossesToPredict,...){
      return(predCrossMeans(AddEffectList=AlleleSubEffectList,
                            CrossesToPredict=CrossesToPredict,
                            doseMat=doseMat,ncores=ncores,predType="BV")) }))
  ## predict MeanTGVs 
  if(modelType=="DirDom"){
    #  Prediction of MeanTGV is only available for the DirDom model
    ### or a model with "genotypic" additive-dominance SNP effects
    ### As implemented, modelType="AD" is the "classical" partition (BVs+ DomDevs)
    predmeans<-predmeans %>%
      # AddEffectList + DomEffectList --> VarTGV; AlleleSubEffectList --> VarBV;
      mutate(AddEffectList=map(EffectList,
                               function(EffectList){
                                 addsnpeff<-map(EffectList$addsnpeff,~t(.))
                                 names(addsnpeff)<-EffectList$Trait
                                 return(addsnpeff) }),
             DomEffectList=map(EffectList,
                               function(EffectList){
                                 domsnpeff<-map(EffectList$domsnpeff,~t(.))
                                 names(domsnpeff)<-EffectList$Trait
                                 return(domsnpeff) })) 
    
    ## prediction of MeanTGVs
    predmeans %<>%
      mutate(predMeans=pmap(.,function(predMeans,AddEffectList,DomEffectList,
                                       CrossesToPredict,...){
        return(predMeans %>% 
                 bind_rows(predCrossMeans(AddEffectList=AddEffectList,
                                          DomEffectList=DomEffectList,
                                          CrossesToPredict=CrossesToPredict,
                                          doseMat=doseMat,ncores=ncores,
                                          predType="TGV"))) }))
    
  }
  predmeans %<>%
    select(-contains("EffectList"),-CrossesToPredict)
  return(predmeans)
}
```

```{r call to predictCrossMeans func}
# cvPredMeans<-predictCrossMeans(modelType=modelType,ncores=ncores,
#                                snpeffs=markEffs,
#                                parentfolds=parentfolds,
#                                doseMat=dosages)
```

## Add DirDom to varPredAccuracy

```{r rename inputs for testing varPredAccuracy}
crossValOut=cvPredVars=predvars
```

```{r varPredAccuracy func TO ADD TO parentWiseCrossVal.R}
varPredAccuracy<-function(crossValOut,snpeffs,ped,modelType,
                          selInd=FALSE,SIwts=NULL){
  
  # Extract and format the GBLUPs from the marker effects object
  gblups<-snpeffs %>%
    unnest(effects) %>%
    filter(Dataset=="testset") %>%
    select(Repeat,Fold,modelType,Trait,gblups) %>%
    unnest(gblups) %>%
    nest(testset_gblups=c(-Repeat,-Fold,-modelType)) # %>% 
  # temporary...
  # for continuing this debug process.... 
  # fixed mistake in getMarkEffs-->fitModel (failed to store GEBV in output) future tests safe
  #mutate(testset_gblups=map(testset_gblups,~mutate(.,GEBV=GEdomval)))
  
  # Use the crossValPred object and the pedigree
  # Create a list of the actual members of each family that were predicted
  # in each repeat-fold
  # Join the GBLUPs for each family member for computing
  # cross sample means, variances, covariances
  out<-crossValOut %>%
    unnest(predVars) %>% 
    distinct(Repeat,Fold,modelType,sireID,damID) %>%
    left_join(ped) %>%
    nest(CrossesToPredict=c(sireID,damID,GID)) %>%
    left_join(gblups)
  out %<>%
    # remove any gebv/getgv NOT in the crosses-to-be-predicted to save mem
    mutate(testset_gblups=map2(testset_gblups,CrossesToPredict,
                               ~semi_join(.x,.y)))
  # for modelType=="A" remove the GETGV as equiv. to GEBV
  if(modelType=="A"){
    out %<>%
      mutate(testset_gblups=map(testset_gblups,
                                ~select(.,Trait,GID,GEBV) %>% 
                                  pivot_longer(.,cols = c(GEBV),
                                               names_to = "predOf",
                                               values_to = "GBLUP") %>%
                                  nest(gblups=-predOf))) }
  # for modelType=="AD" remove the GEDD, pivot to long form GEBV/GETGV
  if(modelType=="AD"){
    out %<>%
      mutate(testset_gblups=map(testset_gblups,
                                ~select(.,Trait,GID,GEBV,GETGV) %>%
                                  pivot_longer(cols = c(GEBV,GETGV),
                                               names_to = "predOf",
                                               values_to = "GBLUP") %>%
                                  nest(gblups=-predOf)))
  }
  if(modelType=="DirDom"){
    out %<>%
      mutate(testset_gblups=map(testset_gblups,
                                ~select(.,Trait,GID,GEBV,GETGV) %>%
                                  pivot_longer(cols = c(GEBV,GETGV),
                                               names_to = "predOf",
                                               values_to = "GBLUP") %>%
                                  nest(gblups=-predOf)))
  }
  out %<>% unnest(testset_gblups)
  
  # make a matrix of GBLUPs for all traits
  # for each family-to-be-predicted
  # in each rep-fold-predOf combination
  out %<>%
    mutate(famgblups=map2(gblups,CrossesToPredict,
                          ~left_join(.x,.y) %>%
                            pivot_wider(names_from = "Trait",
                                        values_from = "GBLUP") %>%
                            nest(gblupmat=c(-sireID,-damID)) %>%
                            mutate(gblupmat=map(gblupmat,~column_to_rownames(.,var="GID"))))) %>%
    select(-CrossesToPredict,-gblups) %>% 
    unnest(famgblups)
  
  #gblupmat<-out$gblupmat[[1]]
  out %<>%
    # outer loop over rep-fold-predtype
    mutate(obsVars=map(gblupmat,function(gblupmat){
      #gblupmat<-famgblups$gblupmat[[1]]
      covMat<-cov(gblupmat)
      # to match predCrossVar output
      ## keep upper tri + diag of covMat
      obsvars<-covMat
      obsvars[lower.tri(obsvars)]<-NA
      obsvars %<>%
        as.data.frame(.) %>%
        rownames_to_column(var = "Trait1") %>%
        pivot_longer(cols = c(-Trait1),
                     names_to = "Trait2",
                     values_to = "obsVar",
                     values_drop_na = T)
      if(selInd==TRUE){
        covmat<-covMat[names(SIwts),names(SIwts)]
        selIndVar<-SIwts%*%covmat%*%SIwts
        obsvars %<>%
          bind_rows(tibble(Trait1="SELIND",
                           Trait2="SELIND",
                           obsVar=selIndVar),.) }
      obsvars %<>% mutate(obsVar=as.numeric(obsVar))
      return(obsvars) }),
      famSize=map_dbl(gblupmat,nrow)) %>%
    select(-gblupmat) %>% 
    unnest(obsVars)
  
  cvout<-crossValOut %>%
    unnest(predVars) %>%
    unnest(predVars) %>%
    select(Repeat,Fold,modelType,predOf,sireID,damID,Trait1,Trait2,predVar)
  
  if(modelType=="AD"){
    ## predVarTGV = predVarBV + predVarDD
    cvout %<>% 
      filter(predOf=="VarBV") %>% 
      bind_rows(cvout %>%
                  group_by(Repeat,Fold,modelType,sireID,damID,Trait1,Trait2) %>%
                  summarize(predVar=sum(predVar),.groups = 'drop') %>%
                  mutate(predOf="VarTGV"))
  }
  
  if(modelType=="DirDom"){
    ## predVarTGV = predVarA + predVarD
    cvout %<>% 
      filter(predOf=="VarBV") %>% 
      bind_rows(cvout %>% 
                  filter(predOf %in% c("VarA","VarD")) %>% 
                  group_by(Repeat,Fold,modelType,sireID,damID,Trait1,Trait2) %>%
                  summarize(predVar=sum(predVar),.groups = 'drop') %>%
                  mutate(predOf="VarTGV"))
  }
  
  cvout %<>%
    nest(predVars=c(Trait1,Trait2,predVar))
  
  if(selInd==TRUE){
    # compute predicted selection index variances
    cvout %<>%
      ## loop over each rep-fold-predOf-sireIDxdamID
      mutate(predVars=future_map(predVars,function(predVars){
        gmat<-predVars %>%
          pivot_wider(names_from = "Trait2",
                      values_from = "predVar") %>%
          column_to_rownames(var = "Trait1") %>%
          as.matrix
        gmat[lower.tri(gmat)]<-t(gmat)[lower.tri(gmat)]
        gmat %<>% .[names(SIwts),names(SIwts)]
        predSelIndVar<-SIwts%*%gmat%*%SIwts
        ## add sel index predictions to component trait
        ## var-covar predictions
        
        predVars<-tibble(Trait1="SELIND",Trait2="SELIND",
                         predVar=as.numeric(predSelIndVar)) %>% 
          bind_rows(predVars)
        return(predVars) }))
  }
  out %<>%
    mutate(predOf=ifelse(predOf=="GEBV","VarBV","VarTGV")) %>% 
    left_join(cvout %>% 
                unnest(predVars)) %>% 
    nest(predVSobs=c(sireID,damID,predVar,obsVar,famSize)) %>% 
    mutate(AccuracyEst=map_dbl(predVSobs,function(predVSobs){
      out<-psych::cor.wt(predVSobs[,c("predVar","obsVar")],
                         w = predVSobs$famSize) %$% r[1,2] %>%
        round(.,3)
      return(out) }))
  return(out)
}
```

```{r call to varPredAccuracy func}
# varPredAccuracy<-varPredAccuracy(modelType = modelType,
#                                    crossValOut = cvPredVars,
#                                    snpeffs = markEffs,
#                                    ped = ped,selInd = selInd,SIwts = SIwts)
```

## Add DirDom to meanPredAccuracy

```{r rename inputs for testing meanPredAccuracy}
crossValOut=cvPredMeans=predmeans
```

```{r meanPredAccuracy - section}
meanPredAccuracy<-function(crossValOut,snpeffs,ped,modelType,
                           selInd=FALSE,SIwts=NULL){
# Extract and format the GBLUPs from the marker effects object
gblups<-snpeffs %>%
  unnest(effects) %>%
  filter(Dataset=="testset") %>%
  select(Repeat,Fold,modelType,Trait,gblups) %>%
  unnest(gblups) %>%
  nest(testset_gblups=c(-Repeat,-Fold,-modelType))

# Use the crossValPred object and the pedigree
# Create a list of the actual members of each family that were predicted
# in each repeat-fold
# Join the GBLUPs for each family member for computing
# cross sample means
out<-crossValOut %>%
  unnest(predMeans) %>%
  distinct(Repeat,Fold,modelType,sireID,damID) %>%
  left_join(ped) %>%
  nest(CrossesToPredict=c(sireID,damID,GID)) %>%
  left_join(gblups)

out %<>%
  # remove any gebv/getgv NOT in the crosses-to-be-predicted to save mem
  mutate(testset_gblups=map2(testset_gblups,CrossesToPredict,
                             ~semi_join(.x,.y)))

# for modelType=="A" and "AD", MeanBV only (remove GETGV)
if(modelType %in% c("A","AD")){
  out %<>%
    mutate(testset_gblups=map(testset_gblups,
                              ~select(.,Trait,GID,GEBV) %>% 
                                pivot_longer(.,cols = c(GEBV),
                                             names_to = "predOf",
                                             values_to = "GBLUP") %>%
                                nest(gblups=-predOf))) }

if(modelType=="DirDom"){
  out %<>%
    mutate(testset_gblups=map(testset_gblups,
                              ~select(.,Trait,GID,GEBV,GETGV) %>%
                                pivot_longer(cols = c(GEBV,GETGV),
                                             names_to = "predOf",
                                             values_to = "GBLUP") %>%
                                nest(gblups=-predOf)))
}
out %<>% unnest(testset_gblups)

# make a matrix of GBLUPs for all traits
# for each family-to-be-predicted
# in each rep-fold-predOf combination
out %<>%
  mutate(famgblups=map2(gblups,CrossesToPredict,
                        ~left_join(.x,.y) %>%
                          pivot_wider(names_from = "Trait",
                                      values_from = "GBLUP") %>%
                          nest(gblupmat=c(-sireID,-damID)) %>%
                          mutate(gblupmat=map(gblupmat,~column_to_rownames(.,var="GID"))))) %>%
  select(-CrossesToPredict,-gblups) %>% 
  unnest(famgblups)

out %<>%
    # outer loop over rep-fold-predtype
    mutate(obsMeans=map(gblupmat,function(gblupmat){
      gblupmeans<-colMeans(gblupmat) %>% as.list
      if(selInd==TRUE){
        selIndMean<-list(SELIND=as.numeric(gblupmeans[names(SIwts)])%*%SIwts)
        gblupmeans<-c(selIndMean,gblupmeans)
      }
      obsmeans<-tibble(Trait=names(gblupmeans),
                       obsMean=as.numeric(gblupmeans))
      return(obsmeans) }),
      famSize=map_dbl(gblupmat,nrow)) %>%
    select(-gblupmat) %>%
    unnest(obsMeans)
  
  
  cvout<-crossValOut %>%
    unnest(predMeans) %>%
    select(Repeat,Fold,modelType,predOf,sireID,damID,Trait,predMean)
  
  if(selInd==TRUE){
    # compute predicted selection index variances
    cvout %<>% 
      pivot_wider(names_from = "Trait",
                  values_from = "predMean") %>% 
      mutate(SELIND=as.numeric(cvout %>% 
                                 pivot_wider(names_from = "Trait",
                                             values_from = "predMean") %>% 
                                 select(any_of(names(SIwts))) %>%
                                 as.matrix(.)%*%SIwts)) %>% 
      pivot_longer(cols = c(SELIND,names(SIwts)),
                   names_to = "Trait",
                   values_to = "predMean")
  }

  out %<>%
    mutate(predOf=ifelse(predOf=="GEBV","MeanBV","MeanTGV")) %>%
    left_join(cvout) %>% 
    nest(predVSobs=c(sireID,damID,predMean,obsMean,famSize)) %>% 
    mutate(AccuracyEst=map_dbl(predVSobs,function(predVSobs){
      out<-psych::cor.wt(predVSobs[,c("predMean","obsMean")],
                         w = predVSobs$famSize) %$% r[1,2] %>%
        round(.,3)
      return(out) }))
    return(out)
}
```
```{r call to meanPredAccuracy func}
# meanPredAccuracy<-meanPredAccuracy(modelType = modelType,
#                                      crossValOut = cvPredMeans,
#                                      snpeffs = markEffs,
#                                      ped = ped,selInd = selInd,SIwts = SIwts)
```

# Pre-deploy test of new functions

Move all functions worked on above into the **parentWiseCrossVal.R**. 

Use them on a slightly larger but still small toy portion of the data.

Final test before full cross-validation analysis.

Start with the "primary inputs", then run the component functions of 
`runParentWiseCrossVal()`.

```{r test inputs runParentWiseCrossVal}
nrepeats=1
nfolds=2
seed=67
ncores=10
ped=ped
gid="GID"
selInd=TRUE
SIwts<-SIwts[1:2]
blups %<>% 
  filter(Trait %in% names(SIwts))

# SOURCE CORE FUNCTIONS
source(here::here("code","parentWiseCrossVal.R"))
source(here::here("code","predCrossVar.R"))
```
```{r runParentWiseCrossVal_test}
runParentWiseCrossVal_test<-function(nrepeats,nfolds,seed=NULL,modelType,
                                     ncores=1,outName=NULL,
                                     ped=ped,gid="GID",blups,
                                     dosages,grms,haploMat,recombFreqMat,
                                     selInd,SIwts = NULL,...){
  # run makeParentFolds
  parentfolds<-makeParentFolds(ped=ped,gid="GID",
                               nrepeats=nrepeats,
                               nfolds=nfolds,
                               seed=seed)
  # limit number crossestopredict for tests
  parentfolds %<>% 
    mutate(CrossesToPredict=map(CrossesToPredict,~slice(.,1:3)))
  
  markEffs<-getMarkEffs(parentfolds,blups=blups,gid=gid,modelType=modelType,
                        grms=grms,dosages=dosages,ncores=ncores)
  
  cvPredVars<-predictCrossVars(modelType=modelType,ncores=ncores,
                               snpeffs=markEffs,
                               parentfolds=parentfolds,
                               haploMat=haploMat,
                               recombFreqMat=recombFreqMat)
  
  cvPredMeans<-predictCrossMeans(modelType=modelType,ncores=ncores,
                                 snpeffs=markEffs,
                                 parentfolds=parentfolds,
                                 doseMat=dosages)
  # crossValOut = cvPredVars
  # snpeffs = markEffs
  varPredAcc<-varPredAccuracy(modelType = modelType,
                                   crossValOut = cvPredVars,
                                   snpeffs = markEffs,
                                   ped = ped,selInd = selInd,SIwts = SIwts)
  
  meanPredAcc<-meanPredAccuracy(modelType = modelType,
                                     crossValOut = cvPredMeans,
                                     snpeffs = markEffs,
                                     ped = ped,selInd = selInd,SIwts = SIwts)
  
  accuracy_out<-list(meanPredAccuracy=meanPredAcc,
                     varPredAccuracy=varPredAcc)
  return(accuracy_out)
}
```

```{r test run modelType DirDom}
cvDirDom_test<-runParentWiseCrossVal_test(nrepeats=1,nfolds=2,seed=67,
                                          modelType="DirDom",
                                          ncores=10,ped=ped,blups=blups,
                                          dosages=dosages,grms=grms,haploMat=haploMat,recombFreqMat=recombFreqMat,
                                          selInd=TRUE,SIwts=SIwts)
cvDirDom_test2reps<-runParentWiseCrossVal_test(nrepeats=2,nfolds=2,seed=67,
                                               modelType="DirDom",
                                               ncores=20,ped=ped,blups=blups,
                                               dosages=dosages,grms=grms,haploMat=haploMat,recombFreqMat=recombFreqMat,
                                               selInd=TRUE,SIwts=SIwts)
```


```{r test run modelType AD}
grmsAD<-list(A=readRDS(file=here::here("output","kinship_A_IITA_2021May13.rds")),
             D=readRDS(file=here::here("output",
                                       "kinship_D_IITA_2021May13.rds")))
cvAD_test<-runParentWiseCrossVal_test(nrepeats=1,nfolds=2,seed=67,
                                      modelType="AD",
                                      ncores=10,ped=ped,blups=blups,
                                      dosages=dosages,grms=grmsAD,
                                      haploMat=haploMat,
                                      recombFreqMat=recombFreqMat,
                                      selInd=TRUE,SIwts=SIwts)
cvAD_test2reps<-runParentWiseCrossVal_test(nrepeats=2,nfolds=2,seed=67,
                                           modelType="AD",
                                           ncores=20,ped=ped,blups=blups,
                                           dosages=dosages,grms=grmsAD,
                                           haploMat=haploMat,
                                           recombFreqMat=recombFreqMat,
                                           selInd=TRUE,SIwts=SIwts)
```

## Final comments

Multiple debugging test iterations on both the DirDom and AD model have now been passed. 

Changes will now be committed with work shown, and then a revised version will be written over it, implementing a full cross-validation analysis with both models, using the now fully operational battlesta.... fully operational code.

# Full runs - TO DO

```{r model AD - 5 full reps - parent-wise CV}
cvAD_5rep<-runParentWiseCrossVal(nrepeats=5,nfolds=5,seed=0407,modelType="AD",
                                 ncores=20,outName="output/cvAD_1rep",
                                 ped=ped,gid="GID",blups=blups,
                                 dosages=dosages,haploMat=haploMat,
                                 grms=grms,recombFreqMat = recombFreqMat,
                                 selInd = TRUE, SIwts = SIwts)
saveRDS(cvAD_5rep,here::here("output","cvAD_5rep_predAccuracy.rds"))
```
```{r model DirDom - 5 full reps - parent-wise CV}
cvAD_5rep<-runParentWiseCrossVal(nrepeats=5,nfolds=5,seed=0407,modelType="AD",
                                 ncores=20,outName="output/cvAD_1rep",
                                 ped=ped,gid="GID",blups=blups,
                                 dosages=dosages,haploMat=haploMat,
                                 grms=grms,recombFreqMat = recombFreqMat,
                                 selInd = TRUE, SIwts = SIwts)
saveRDS(cvAD_5rep,here::here("output","cvAD_5rep_predAccuracy.rds"))
```


# Next step / Results

See [Results](06-Results.html): Home for plots and summary tables.



